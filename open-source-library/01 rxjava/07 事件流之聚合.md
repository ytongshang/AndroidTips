# 事件流之聚合

- [count](#count)
- [first](#first)
- [last](#last)
- [single](#single)
- [reduce](#reduce)
- [scan](#scan)
- [collect](#collect)
- [toList](#tolist)
- [toSortedList](#tosortedlist)
- [toMap](#tomap)
- [toMultimap](#tomultimap)
- [groupBy](#groupby)
- [nest](#nest)


## count

- count 函数和 Java 集合中的 size 或者 length 一样。用来统计源 Observable 完成的时候一共发射了多少个数据

```java
Observable<Integer> values = Observable.range(0, 3);
values.subscribe(new PrintSubscriber("Values"));
values.count().subscribe(new PrintSubscriber("Count"));

```

## first

- first 类似于 take(1) , 发射 源 Observable 中的第一个数据。如果没有数据，则返回 ava.util.NoSuchElementException。还有一个重载的带有 过滤 参数，则返回第一个满足该条件的数据。

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);
values
    .first(v -> v>5)
    .subscribe(new PrintSubscriber("First"));
```

## last

- last是和 first 一样的，区别就是当 源 Observable 完成的时候， 发射最后的数据。 如果使用重载的带 过滤参数的函数，则返回最后一个满足该条件的数据

## single

- single 只会发射源 Observable 中的一个数据，如果使用重载的带过滤条件的函数，则发射符合该过滤条件的那个数据。
- 和 first 、last 不一样的地方是，single 会检查数据流中是否只包含一个所需要的的数据，如果有多个则会抛出一个错误信息。
- 所以 single 用来检查数据流中是否有且仅有一个符合条件的数据。所以 single只有在源 Observable 完成后才能返回

## reduce

- 该思想是使用源 Observable 中的所有数据两两组合来生成一个单一的 数据。在大部分重载函数中都需要一个函数用来定义如何组合两个数据变成一个

```java
Observable<Integer> values = Observable.range(0,5);
values
    .reduce((i1,i2) -> i1+i2)
    .subscribe(new PrintSubscriber("Sum"));
values
    .reduce((i1,i2) -> (i1>i2) ? i2 : i1)
    .subscribe(new PrintSubscriber("Min"));

Sum: 10
Sum: Completed
Min: 0
Min: Completed
```

- 在 Rx 中是使用从数据流中第一个数据到最后一个数据（从左往右）中的数据来调用 参数 accumulator ，accumulator 用前一次返回的结果和下一个数据来再次调用 accumulator 

- accumulator 参数返回的数据类型和 源 Observable 的数据类型可能是不一样的。accumulator 的第一个参数为前一步 accumulator 执行的结果，而第二个参数为 下一个数据。 使用一个初始化的值作为整个处理流程的开始

```java
Observable<String> values = Observable.just("Rx", "is", "easy");
values
    .reduce(0, (acc,next) -> acc + 1)
    .subscribe(new PrintSubscriber("Count"));

Count: 3
Count: Completed
```

## scan

- scan 和 reduce 很像，不一样的地方在于 scan会发射所有中间的结算结果。

```java
Observable<Integer> values = Observable.range(0,5);

values
    .scan((i1,i2) -> i1+i2)
    .subscribe(new PrintSubscriber("Sum"));

Sum: 0
Sum: 1
Sum: 3
Sum: 6
Sum: 10
Sum: Completed

```

## collect

## toList

- 将Observable中的数据转换为一个list

```java
Observable<Integer> values = Observable.range(10,5);

values
    .toList()
    .subscribe(v -> System.out.println(v));

```

## toSortedList

- toSortedList 和toList类似，返回一个排序后的 list

```java
public final Observable<java.util.List<T>> toSortedList()
public final Observable<java.util.List<T>> toSortedList(
    Func2<? super T,? super T,java.lang.Integer> sortFunction)
```

## toMap

- toMap 把数据流 T 变为一个 Map<TKey,T>

## toMultimap

- 通常情况下多个 value 的 key 可能是一样的。 一个 key 可以映射多个 value 的数据结构为 multimap，multimap 的 value 为一个集合。该过程被称之为 “grouping” （分组）

```java
Observable<Person> values = Observable.just(
    new Person("Will", 35),
    new Person("Nick", 40),
    new Person("Saul", 35)
);

values
    .toMultimap(
        person -> person.age,
        person -> person.name)
    .subscribe(new PrintSubscriber("toMap"));

toMap: {35=[Will, Saul], 40=[Nick]}
toMap: Completed

```

## groupBy

- groupBy 是 toMultimap 函数的 Rx 方式的实现。groupBy 根据每个源Observable 发射的值来计算一个 key， 然后为每个 key 创建一个新的 Observable并把key 一样的值发射到对应的新 Observable 中。
- 返回的结果为 GroupedObservable。 每次发现一个新的key，内部就生成一个新的 GroupedObservable并发射出来。和普通的 Observable 相比 多了一个 getKey 函数来获取 分组的 key。来自于源Observable中的值会被发射到对应 key 的 GroupedObservable 中

```java
Observable<String> values = Observable.just(
        "first",
        "second",
        "third",
        "forth",
        "fifth",
        "sixth"
);

values.groupBy(word -> word.charAt(0))
    .subscribe(
        group -> group.last()
            .subscribe(v -> System.out.println(group.getKey() + ": " + v))
    );

s: sixth
t: third
f: fifth

```

## nest

- 当和 嵌套的 Observable 打交道的时候，就要使用 nest 函数了。nest 函数把一个普通的非 嵌套 Observable 变为一个嵌套的 Observable。 nest 把一个源 Observable 变为一个嵌套的 Observable 发射出去就结束了

```java
Observable.range(0, 3)
    .nest()
    .subscribe(ob -> ob.subscribe(System.out::println));
```