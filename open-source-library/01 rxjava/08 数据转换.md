# 数据转换

- [map](#map)
- [cast 与ofType](#cast-与oftype)
- [timestamp 与timeinterval](#timestamp-与timeinterval)
- [materialize与dematerialize](#materialize与dematerialize)
- [flatmap](#flatmap)

## map

- map 使用一个转换的参数把源Observable 中的数据转换为另外一种类型的数据。返回的 Observable 中包含了转换后的数据

```java
public final <R> Observable<R> map(Func1<? super T,? extends R> func)
```

## cast 与ofType

- cast 是把一个对象强制转换为子类型的缩写形式。 
- 如果遇到类型不一样的对象的话，就会抛出一个 error
- 如果你不想处理类型不一样的对象，则可以用 ofType 。 该函数用来判断数据是否为该类型，如果不是则跳过这个数据

```java
Observable<Object> values = Observable.just(0, 1, 2, 3);
 // 我们知道其中的参数为Integer,强制转换
values
    .cast(Integer.class)
    .subscribe(new PrintSubscriber("Map"));

Observable<Object> values = Observable.just(0, 1, "2", 3);
// 忽略了"2",因为它不是Integer类型的
values
    .ofType(Integer.class)
    .subscribe(new PrintSubscriber("Map"));
```

## timestamp 与timeinterval

- 这两个函数可以给数据流中的数据添加额外的时间相关的信息。
- timestamp 把数据转换为 Timestamped 类型，里面包含了原始的数据和一个原始数据是何时发射的时间戳
- 如果你想知道前一个数据和当前数据发射直接的时间间隔，则可以使用 timeInterval 函数
- 这两个函数中的时间对于记录日志和调试程序是非常有用的

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

values.take(3)
    .timestamp()
    .subscribe(new PrintSubscriber("Timestamp"));

Timestamp: Timestamped(timestampMillis = 1428611094943, value = 0)
Timestamp: Timestamped(timestampMillis = 1428611095037, value = 1)
Timestamp: Timestamped(timestampMillis = 1428611095136, value = 2)
Timestamp: Completed

Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);
values.take(3)
    .timeInterval()
    .subscribe(new PrintSubscriber("TimeInterval"));

TimeInterval: TimeInterval [intervalInMilliseconds=131, value=0]
TimeInterval: TimeInterval [intervalInMilliseconds=75, value=1]
TimeInterval: TimeInterval [intervalInMilliseconds=100, value=2]
TimeInterval: Completed
```

## materialize与dematerialize

- materialize 对于记录日志也是很有用的。materialize 把数据转换为元数据发射出去
- dematerialize 函数会把 materialize 转换后的Observable 再还原为 源 Observable
- 元数据中包含了源 Observable 所发射的动作，是调用 onNext 还是 onComplete。注意上图中，源 Observable 结束的时候， materialize 还会发射一个 onComplete 数据，然后才发射一个结束事件

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

values.take(3)
    .materialize()
    .subscribe(new PrintSubscriber("Materialize"));

Materialize: [rx.Notification@a4c802e9 OnNext 0]
Materialize: [rx.Notification@a4c802ea OnNext 1]
Materialize: [rx.Notification@a4c802eb OnNext 2]
Materialize: [rx.Notification@18d48ace OnCompleted]
Materialize: Completed
```

## flatmap

- map 把一个数据转换为另外一个数据。而 flatMap 把源 Observable 中的一个数据替换为任意数量的数据，可以为 0 个，也可以为无限个。 flatMap 把源 Observable 中的一个数据转换为一个新的 Observable 发射出去

- flatMap 的参数会把 源 Observable 中发射的每个数据转换为一个新的 Observable， 然后 flatMap 再把这些新的 Observable 中发射的数据发射出来。由同一个Observable变化产生的数据都是按照他们产生的顺序发射出来，但是由不同的原Observable产生的数据的顺序可能与原Observable会不一样

