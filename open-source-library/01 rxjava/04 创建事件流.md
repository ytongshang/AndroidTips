# 创建事件流

- [just](#just)
- [empty](#empty)
- [never](#never)
- [error](#error)
- [defer](#defer)
- [create](#create)
- [range](#range)
- [interval](#interval)
- [intervalRange]
- [timer](#timer)
- [from](#from)

## create

- Observable.create, 与subject 相比，数据源被封装起来了，并和不相关的代码隔离开了。
- 其次：Subject 有一些不太明显的问题，通过使用 Subject 你自己在管理状态，并且任何访问该 Subject 对象的人都可以往里面发送数据然后改变事件流， 使用 create 创建的 Observable，当 Observable 创建的时候，你的函数还没有执行，只有当有 Subscriber 订阅的时候才执行。这就意味着每次当有 Subscriber 订阅的时候，该函数就执行一次。和 defer 的功能类似

## defer

- Observable.defer， defer 的参数是一个返回一个 Observable 对象的函数。该函数返回的 Observable 对象就是 defer 返回的 Observable 对象。 重点是，每当一个新的 Subscriber 订阅的时候，这个函数就重新执行一次。

```java
Observable<Long>  now  =  Observable.just(System.currentTimeMillis());
now.subscribe(System.out::println);
Thread.sleep(1000);
now.subscribe(System.out::println);

1431443908375
1431443908375

Observable<Long> now = Observable.defer(() ->
        Observable.just(System.currentTimeMillis()));
now.subscribe(System.out::println);
Thread.sleep(1000);
now.subscribe(System.out::println);

1431444107854
1431444108858

```

## empty

- Observable.empty， 这个函数创建的 Observable 只发射一个 onCompleted 事件就结束了。

## never

- Observable.never， 这个 Observable 将不会发射任何事件和数据

## error

- Observable.error， 这个 Observable 将会发射一个 error 事件，然后结束

## from

```java
public static <T> Observable<T> fromArray(T... items)
public static <T> Observable<T> fromCallable(Callable<? extends T> supplier)
public static <T> Observable<T> fromFuture(Future<? extends T> future)
public static <T> Observable<T> fromFuture(Future<? extends T> future, Scheduler scheduler)
public static <T> Observable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit)
public static <T> Observable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler)
public static <T> Observable<T> fromIterable(Iterable<? extends T> source)
public static <T> Observable<T> fromPublisher(Publisher<? extends T> publisher)
```

- bservable.from， 在 Java 并发框架中经常使用 Future 来获取异步结果。 通过使用 from 可以把 Future 的结果发射到 Observable 中

```java
FutureTask<Integer> f = new FutureTask<Integer>(() -> {
    Thread.sleep(2000);
    return 21;
});
new Thread(f).start();
Observable<Integer> values = Observable.from(f);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);

Received:  21
Completed
```

- 当 FutureTask 执行完后， Observable 发射 Future 获取到的结果然后结束。如果任务 取消了，则 Observable 会发射一个 java.util.concurrent.CancellationException 错误信息， 你还可以对 Future 设置超时时间：

```java
Observable<Integer> values = Observable.from(f, 1000, TimeUnit.MILLISECONDS);
```

- 当过了超时时间后， Future 还是没有返回结果， Observable 可以忽略其结果并发射一个 TimeoutException

- Observable.from， 可以用一个数据集合或者一个可以遍历的iterable 的数据来生成一个 Observable。逐个发射集合中的数据，最后发射一个 onCompleted 事件

```java
Integer[] is = {1,2,3};
Observable<Integer> values = Observable.from(is);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);

3
4
5

Received: 1
Received: 2
Received: 3
Completed

```

## just

- Observable.just， just 函数创建一个发射预定义好的数据的 Observable ，发射完这些数据后，事件流就结束了

```java
Observable<String> values = Observable.just("one", "two", "three");
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);

Received:  one
Received:  two
Received:  three
Completed
```

## range

- Observable.range， 该函数发射一个整数序列

```java
Observable<Integer>  values  =  Observable.range(10,  15);
```

## interval

- Observable.interval， 创建一个无限的计时序列，每隔一段时间发射一个数字，从 0 开始
- 下面这个序列如果我们不调用 unsubscribe 的话，这个序列是不会停止的。

```java
Observable<Long> values = Observable.interval(1000, TimeUnit.MILLISECONDS);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
System.in.read();

3
4
5
6

Received: 0
Received: 1
Received: 2
Received: 3
...
```

## intervalRange

```java
 public static Observable<Long> intervalRange(long start, long count,
                long initialDelay, long period,
                TimeUnit unit, Scheduler scheduler)
```

## timer

- Observable.timer， Observable.timer 有两个重载函数
- 第一个示例创建了一个 Observable， 该 Observable 等待一段时间，然后发射数据 0 ，然后就结束了

```java
Observable<Long> values = Observable.timer(1, TimeUnit.SECONDS);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);

Received:  0
Completed
```

- 另外一个示例是，先等待一段时间，然后开始按照间隔的时间一直发射数据：

```java
Observable<Long> values = Observable.timer(2, 1, TimeUnit.SECONDS);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);

2
3
4
5

Received: 0
Received: 1
Received: 2
...
```


