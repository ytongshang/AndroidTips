# 过滤数据

- [filter](#filter)
- [distinct](#distinct)
- [distinctUntilChanged](#distinctuntilchanged)
- [ignoreElements](#ignoreelements)
- [skip 和 take](#skip-和-take)
- [skipWhile 和 takeWhile](#skipwhile-和-takewhile)
- [skipLast 和 takeLast](#skiplast-和-takelast)
- [takeUntil 和 skipUntil](#takeuntil-和-skipuntil)


- 所有的操作符都返回一个不影响前一个 Observable 的新 Observable 。 整个 Rx 框架都遵守该原则。通过创建新的 Observable 来转换之前的 Observable而不会对之前的 Observable 造成干扰。订阅到初始 Observable 的 Subscribers 不会受到任何影响，但是在后面的章节中也会看到，开发者也需要当心该原则

## filter

- filter 函数使用一个 predicate 函数接口来判断每个发射的值是否能通过这个判断

```java
Observable<Integer> values = Observable.range(0,10);
Subscription oddNumbers = values
    .filter(v -> v % 2 == 0)
    .subscribe(
        v -> System.out.println(v),
        e -> System.out.println("Error: " + e),
        () -> System.out.println("Completed")
    );

0
2
4
6
8
Completed
```

## distinct

- distinct 函数用来过滤掉已经出现过的数据了。 distinct 还有一个重载函数，该函数有个生成 key 的参数。每个发射的数据都使用该参数生成一个 key，然后使用该key 来判断数据是否一样

```java
Observable<Integer> values = Observable.create(o -> {
    o.onNext(1);
    o.onNext(1);
    o.onNext(2);
    o.onNext(3);
    o.onNext(2);
    o.onCompleted();
});
Subscription subscription = values
    .distinct()
    .subscribe(
        v -> System.out.println(v),
        e -> System.out.println("Error: " + e),
        () -> System.out.println("Completed")
    );

1
2
3
Completed
```


## distinctUntilChanged 

- 与distinct的区别是 distinctUntilChanged 只过滤相邻的 key 一样的数据

```java
Observable<Integer> values = Observable.create(o -> {
    o.onNext(1);
    o.onNext(1);
    o.onNext(2);
    o.onNext(3);
    o.onNext(2);
    o.onCompleted();
});
Subscription subscription = values
    .distinctUntilChanged()
    .subscribe(
        v -> System.out.println(v),
        e -> System.out.println("Error: " + e),
        () -> System.out.println("Completed")
    );

1
2
3
2
Completed
```

## ignoreElements

- ignoreElements 会忽略所有发射的数据，只让 onCompleted 和 onError 可以通过。

## skip 和 take

- take 从头开始获取前 N 个数据，而 skip 则是从头开始 跳过 N 个数据。注意，如果发射的数据比 N 小，则这两个函数都会发射一个 error。

## skipWhile 和 takeWhile

- 这两个函数是使用一个 predicate 参数来当做判断条件。 如果判断条件返回为 ture， 则 - takeWhile 保留该数据。
- skipWhile 跳过过滤条件为 true 的数据

## skipLast 和 takeLast

- skip 和 take 是从头开始索引数据，而 skipLast 和 takeLast 和他们相反，是从末尾开始索引数据

## takeUntil 和 skipUntil

- takeUntil 和 skipUntil 这两个函数和 takeWhile 、skipWhile 刚好相反。 当判断条件为 false 的时候， takeUntil 保留该数据
- takeUntil 和 skipUntil 还有另外一种不一样的重载函数。切断的条件为 另外一个 Observable 发射数据的时刻





