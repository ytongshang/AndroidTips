# 过滤数据

- [filter](#filter)
- [distinct](#distinct)
- [distinctUntilChanged](#distinctuntilchanged)
- [ignoreElements](#ignoreelements)
- [skip 和 take](#skip-和-take)
- [skipWhile 和 takeWhile](#skipwhile-和-takewhile)
- [skipLast 和 takeLast](#skiplast-和-takelast)
- [takeUntil 和 skipUntil](#takeuntil-和-skipuntil)

- 所有的操作符都返回一个不影响前一个 Observable 的新 Observable 。 整个 Rx 框架都遵守该原则。通过创建新的 Observable 来转换之前的 Observable而不会对之前的 Observable 造成干扰。订阅到初始 Observable 的 Subscribers 不会受到任何影响，但是在后面的章节中也会看到，开发者也需要当心该原则

## filter

- filter 函数使用一个 predicate 函数接口来判断每个发射的值是否能通过这个判断

```java
Observable<Integer> values = Observable.range(0,10);
Subscription oddNumbers = values
    .filter(v -> v % 2 == 0)
    .subscribe(
        v -> System.out.println(v),
        e -> System.out.println("Error: " + e),
        () -> System.out.println("Completed")
    );

// output
0
2
4
6
8
Completed
```

## 去重

### distinct

```java
public final Flowable<T> distinct()
public final <K> Flowable<T> distinct(Function<? super T, K> keySelector)
distinct(Function<? super T, K> keySelector,Callable<? extends Collection<? super K>> collectionSupplier)
```

- **distinct 函数用来过滤掉已经出现过的数据**
- 每个发射的数据都使用该keySelector生成一个 key，然后使用该key 来判断数据是否一样

### distinctUntilChanged

```java
public final Flowable<T> distinctUntilChanged()
public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector)
public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer)
```

- **distinctUntilChanged 只过滤相邻的 key 一样的数据**

## 特定位置

### first

```java
// rxjava2
public final Maybe<T> firstElement()
public final Single<T> first(T defaultItem)
public final Single<T> firstOrError()
```

### elementAt

```java
public final Maybe<T> elementAt(long index)
public final Single<T> elementAt(long index, T defaultItem)
public final Single<T> elementAtOrError(long index)
```

### last

```java
public final Maybe<T> lastElement()
public final Single<T> last(T defaultItem)
public final Single<T> lastOrError()
```

- 与first类似

## elementAt

```java
```

- 因为rxjava2中不允许null，所以firstElement返回的是一个Maybe对象

## ignoreElements

- ignoreElements 会忽略所有发射的数据，只让 onCompleted 和 onError 可以通过。

## skip 和 take

- take 从头开始获取前 N 个数据，而 skip 则是从头开始 跳过 N 个数据。注意，如果发射的数据比 N 小，则这两个函数都会发射一个 error。

## skipWhile 和 takeWhile

- 这两个函数是使用一个 predicate 参数来当做判断条件。 如果判断条件返回为 ture， 则 - takeWhile 保留该数据。
- skipWhile 跳过过滤条件为 true 的数据

## skipLast 和 takeLast

- skip 和 take 是从头开始索引数据，而 skipLast 和 takeLast 和他们相反，是从末尾开始索引数据

## takeUntil 和 skipUntil

- takeUntil 和 skipUntil 这两个函数和 takeWhile 、skipWhile 刚好相反。 当判断条件为 false 的时候， takeUntil 保留该数据
- takeUntil 和 skipUntil 还有另外一种不一样的重载函数。切断的条件为 另外一个 Observable 发射数据的时刻
