# 过滤数据

- [filter](#filter)
- [distinct](#distinct)
- [distinctUntilChanged](#distinctuntilchanged)
- [ignoreElements](#ignoreelements)
- [skip 和 take](#skip-和-take)
- [skipWhile 和 takeWhile](#skipwhile-和-takewhile)
- [skipLast 和 takeLast](#skiplast-和-takelast)
- [takeUntil 和 skipUntil](#takeuntil-和-skipuntil)

- 所有的操作符都返回一个不影响前一个 Observable 的新 Observable 。 整个 Rx 框架都遵守该原则。通过创建新的 Observable 来转换之前的 Observable而不会对之前的 Observable 造成干扰。订阅到初始 Observable 的 Subscribers 不会受到任何影响，但是在后面的章节中也会看到，开发者也需要当心该原则

## filter

- filter 函数使用一个 predicate 函数接口来判断每个发射的值是否能通过这个判断

```java
Observable<Integer> values = Observable.range(0,10);
Subscription oddNumbers = values
    .filter(v -> v % 2 == 0)
    .subscribe(
        v -> System.out.println(v),
        e -> System.out.println("Error: " + e),
        () -> System.out.println("Completed")
    );

// output
0
2
4
6
8
Completed
```

## 去重

### distinct

```java
public final Flowable<T> distinct()
public final <K> Flowable<T> distinct(Function<? super T, K> keySelector)
distinct(Function<? super T, K> keySelector,Callable<? extends Collection<? super K>> collectionSupplier)
```

- **distinct 函数用来过滤掉已经出现过的数据**
- 每个发射的数据都使用该keySelector生成一个 key，然后使用该key 来判断数据是否一样

### distinctUntilChanged

```java
public final Flowable<T> distinctUntilChanged()
public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector)
public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer)
```

- **distinctUntilChanged 只过滤相邻的 key 一样的数据**

## 特定位置

- 因为rxjava2中不允许null，所以特定位置元素返回的是一个Maybe对象

### first

```java
// rxjava2
public final Maybe<T> firstElement()
public final Single<T> first(T defaultItem)
public final Single<T> firstOrError()
```

### elementAt

```java
public final Maybe<T> elementAt(long index)
public final Single<T> elementAt(long index, T defaultItem)
public final Single<T> elementAtOrError(long index)
```

### last

```java
public final Maybe<T> lastElement()
public final Single<T> last(T defaultItem)
public final Single<T> lastOrError()
```

## skip元素

```java
// 跳过前面count个元素
public final Flowable<T> skip(long count)

// 丢弃原始Publisher开始的那段时间发射的数据
public final Flowable<T> skip(long time, TimeUnit unit)
public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler)

// 跳过后面count个元素
public final Flowable<T> skipLast(int count)
public final Flowable<T> skipLast(long time, TimeUnit unit)
public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler)
public final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError)
public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError)
public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize)

// 跳过原来publisher发送的数据，直到other开始发送数据才不跳过
public final <U> Flowable<T> skipUntil(Publisher<U> other)

// 对于原publisher发送的数据t,只要predictate.test(t)为true，就跳过，否则不跳过
public final Flowable<T> skipWhile(Predicate<? super T> predicate)
```

## take

- 与skip类似，不过不是跳过一些元素，而是取这些元素

```java
// 只保留前n个元素
public final Flowable<T> take(long count)

// 取开始一段时间发送的数据
public final Flowable<T> take(long time, TimeUnit unit)
public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler)

public final Flowable<T> takeLast(int count)
public final Flowable<T> takeLast(long count, long time, TimeUnit unit)
public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler)
public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize)
public final Flowable<T> takeLast(long time, TimeUnit unit)
public final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError)
public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler)
public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError)
public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize)

public final Flowable<T> takeUntil(Predicate<? super T> stopPredicate)
public final <U> Flowable<T> takeUntil(Publisher<U> other)
public final Flowable<T> takeWhile(Predicate<? super T> predicate)
```

## ignoreElements

```java
public final Completable ignoreElements()
```

- ignoreElements 会忽略所有发射的数据，只让 onCompleted 和 onError 可以通过。

## throttle

```java
public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit)
public final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler)

public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit)
public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler)

public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit)
public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler)
```

