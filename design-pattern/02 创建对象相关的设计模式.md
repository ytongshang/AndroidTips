# 创建对象相关的设计模式

- [Builder模式](#builder模式)
- [工厂方法](#工厂方法)
- [抽象工厂](#抽象工厂)
- [原型模式](#原型模式)
    - [原型设计模式的定义](#原型设计模式的定义)
    - [原型设计模式的优势](#原型设计模式的优势)
    - [原型设计模式的注意点](#原型设计模式的注意点)
    - [原型设计模式的示例](#原型设计模式的示例)

## Builder模式

## 工厂方法

- 定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类，一般用于现在还不知道要实例化哪些具体的类

```java
public abstrace class A {
    public void f() {
        Base base = createBase();
        ......
    }
    public abstrace createBase();
}
public class B extends A {
    public createBase() {
        //创建属于B的具休Base类型
    }
}
```

## 抽象工厂

- 提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类，一般用于想创建产品家族，或者想将创建的产品集

```java
public interface abstractFactory {
    Base createA();
    Base createB();
}
public class AFactory implements abstract abstractFactory {
    Base createA() {}
    Base createB() {}
}
public class BFactory implements abstract abstractFactory {
    Base createA() {}
    Base createB() {}
}

```

## 原型模式

### 原型设计模式的定义

- 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

### 原型设计模式的优势

- 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，
 特别是复制大对象时，性能的差别非常明显。
- 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单

### 原型设计模式的注意点

- java的clone方法有风险，**要注意浅拷贝与深拷贝**
- 自己实现拷贝函数,拷贝构造函数

### 原型设计模式的示例

- Okhttpclient.newBuilder()方法

```java
public Builder newBuilder() {
    return new Builder(this);
}

Builder(OkHttpClient okHttpClient) {
    this.dispatcher = okHttpClient.dispatcher;
    this.proxy = okHttpClient.proxy;
    this.protocols = okHttpClient.protocols;
    this.connectionSpecs = okHttpClient.connectionSpecs;
    this.interceptors.addAll(okHttpClient.interceptors);
    this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
    this.proxySelector = okHttpClient.proxySelector;
    this.cookieJar = okHttpClient.cookieJar;
    this.internalCache = okHttpClient.internalCache;
    this.cache = okHttpClient.cache;
    this.socketFactory = okHttpClient.socketFactory;
    this.sslSocketFactory = okHttpClient.sslSocketFactory;
    this.hostnameVerifier = okHttpClient.hostnameVerifier;
    this.certificatePinner = okHttpClient.certificatePinner;
    this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
    this.authenticator = okHttpClient.authenticator;
    this.connectionPool = okHttpClient.connectionPool;
    this.dns = okHttpClient.dns;
    this.followSslRedirects = okHttpClient.followSslRedirects;
    this.followRedirects = okHttpClient.followRedirects;
    this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
    this.connectTimeout = okHttpClient.connectTimeout;
    this.readTimeout = okHttpClient.readTimeout;
    this.writeTimeout = okHttpClient.writeTimeout;
}

```